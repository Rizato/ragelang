// Fledgling - A Ragelang Game 
// A fledgling bird must return to its nest at the top of a tree
// State enums..................................................
enum GameState { // ............................................
 // ............................................................
  Playing, // ..................................................
  Won, // ......................................................
  Paused // ....................................................
} // ...........................................................
enum MenuState { // ............................................
 // ............................................................
  None, // .....................................................
  Pause // ....................................................
} // ...........................................................
enum JumpState { // ............................................
 // ............................................................
  Grounded, // .................................................
  Jumping, // ..................................................
  Gliding, // ..................................................
  PendingGlide, // .............................................
  Falling // ..................................................
} // ...........................................................
// Game state...................................................
game_state = Playing // ........................................
menu_state = None // ..........................................
max_height = 0 // ............................................
// Audio settings (0-10 scale, passed to music() and sound())
// Use like: music("assets/sounds/music.mp3", music_volume)..
// Use like: sound("assets/sounds/jump.wav", sfx_volume).....
sfx_volume = 5 // ...........................................
music_volume = 5 // .........................................
// Level....................................................
level = prototype() // .....................................
level.tile_size = 16 // ....................................
level.tile_width = 100 // ..................................
level.tile_height = 64 // ..................................
level.width = level.tile_size * level.tile_width // ........
level.height = level.tile_size * level.tile_height // ......
// TODO Camera should take screen size into account ........
camera = { // ................................................
 // ..........................................................
  width: 45, // .............................................
  height: 25 // .............................................
} // ...........................................................
// Calculate camera scale based on screen size (pixels per tile) ...
camera.scale = min(width() / camera.width, height() / camera.height)
// Player.....................................................................
player = prototype() // ......................................................
player.x = 87.0 // ............................................................
player.y = 20.0 // ...........................................................
// Initialize camera position at correct locked position ..................................
// Calculate viewport size in tiles (use camera dimensions) ................................
init_half_view_width = camera.width / 2 // .................................................
init_half_view_height = camera.height / 2 // ...............................................
// Calculate camera bounds ..................................................................
init_min_camera_x = init_half_view_width // ................................................
init_max_camera_x = level.tile_width - init_half_view_width // .............................
init_min_camera_y = init_half_view_height // ...............................................
init_max_camera_y = level.tile_height - init_half_view_height // ...........................
// Calculate lock thresholds ...............................................................
init_lock_x = camera.width / 2 // ..........................................................
init_lock_y = camera.height / 2 // .........................................................
// Center on player first ..................................................................
init_desired_x = player.x + 0.5 // .........................................................
init_desired_y = player.y + 0.5 // .........................................................
// Calculate viewport edges ................................................................
init_viewport_left = init_desired_x - init_half_view_width // ..............................
init_viewport_right = init_desired_x + init_half_view_width // .............................
init_viewport_top = init_desired_y - init_half_view_height // ..............................
init_viewport_bottom = init_desired_y + init_half_view_height // ...........................
// Apply horizontal locking ................................................................
if (init_viewport_left <= init_lock_x) { // ................................................
 camera.x = init_min_camera_x // ..........................................................
} else if (init_viewport_right >= level.tile_width - init_lock_x) { // .....................
 camera.x = init_max_camera_x // ..........................................................
} else { // ................................................................................
 camera.x = init_desired_x // .............................................................
} // .......................................................................................
// Apply vertical locking ..................................................................
if (init_viewport_top <= init_lock_y) { // .................................................
 camera.y = init_min_camera_y // ..........................................................
} else if (init_viewport_bottom >= level.tile_height - init_lock_y) { // ...................
 camera.y = init_max_camera_y // ..........................................................
} else { // ................................................................................
 camera.y = init_desired_y // .............................................................
} // .......................................................................................
player.vel_x = 0 // .......................................................................
player.vel_y = 0 // ......................................................................
player.width = 2 // .....................................................................
player.height = 2 // ...................................................................
player.glide_height = 1 // ............................................................
player.jump_state = Grounded // .......................................................
player.coyote_time = 0 // ............................................................
player.coyote_time_max = 0.15 // ....................................................
player.jump_buffer = 0 // ..........................................................
player.jump_buffer_max = 0.15 // ..................................................
player.momentum = 0 // ...........................................................
player.momentum_max = 10.0 // ...................................................
player.momentum_gain = 4.0 // ..................................................
player.momentum_loss_air = 4.7 // .............................................
player.momentum_loss_ground = 6.25 // ........................................
// Physics constants (values in tiles per second) ...........................
gravity = 37.5 // ..........................................................
jump_force_base = -14 // ..................................................
jump_force_momentum_mult = 0.06 // .......................................
jump_held_gravity = 18.0 // .............................................
glide_gravity = 9.0 // .................................................
glide_velocity_min = 6.25 // ..........................................
ground_speed = 4.0 // ................................................
air_speed = 4.0 // ..................................................
visuals = []  // ...................................................
// Level geometry..................................................
hitboxes = [] // .................................................
// Ground section hitboxes.......................................
// Coordinates are in tiles, not pixels ........................
nest = {x: 5, y: 7, w: 6, h: 4, type: "nest"} // ..............
// Ground covers the whole bottom of the level ........................................
push(hitboxes, {x: 0, y: 62, w: level.tile_width, h: 2, type: "ground", friction: 0.7})
// Cliff walls bound the level all the way up ..............................................
push(hitboxes, {x: 0, y: 0, w: 4, h: level.tile_height - 2, type: "rock", friction: 1.0}) //................
push(hitboxes, {x: level.tile_width - 4, y: 0, w: 4, h: level.tile_height - 2, type: "rock", friction: 1.0})
// Log over the apples ....................................................................................
push(hitboxes, {x: 17, y: 48, w: 35, h: 2, type: "wood", friction: 0.8}) // ...............................
push(hitboxes, {x: 55, y: 48, w: 4, h: 2, type: "wood", friction: 0.8}) // ...............................
push(hitboxes, {x: 17, y: 50, w: 20, h: 2, type: "wood", friction: 0.8}) // ...............................
// Roof dips between apples ..............................................................................
// push(hitboxes, {x: 31, y: 49, w: 4, h: 1, type: "wood", friction: 0.8}) // ............................
// Sideways apple  // .....................................................................................
push(hitboxes, {x: 23, y: 54, w: 6, h: 1, type: "apple", friction: 0.6}) // ..............................
push(hitboxes, {x: 22, y: 55, w: 8, h: 2, type: "apple", friction: 0.6}) // .............................
push(hitboxes, {x: 22, y: 56, w: 7, h: 1, type: "apple", friction: 0.6}) // ............................
push(hitboxes, {x: 22, y: 57, w: 6, h: 2, type: "apple", friction: 0.6}) // ...........................
push(hitboxes, {x: 22, y: 59, w: 8, h: 2, type: "apple", friction: 0.6}) // ..........................
push(hitboxes, {x: 23, y: 61, w: 6, h: 1, type: "apple", friction: 0.6}) // ..........................
push(hitboxes, {x: 20, y: 57, w: 2, h: 2, type: "stem", friction: 0.8}) // ..........................
// vertical apple as well ..........................................................................
push(hitboxes, {x: 40, y: 54, w: 6, h: 1, type: "apple", friction: 0.6}) // .......................
push(hitboxes, {x: 39, y: 55, w: 8, h: 5, type: "apple", friction: 0.6}) // ......................
push(hitboxes, {x: 39, y: 60, w: 3, h: 1, type: "apple", friction: 0.6}) // .....................
push(hitboxes, {x: 44, y: 60, w: 3, h: 1, type: "apple", friction: 0.6}) // ....................
push(hitboxes, {x: 40, y: 61, w: 2, h: 1, type: "apple", friction: 0.6}) // ...................
push(hitboxes, {x: 44, y: 61, w: 2, h: 1, type: "apple", friction: 0.6}) // ..................
push(hitboxes, {x: 42, y: 52, w: 2, h: 2, type: "stem", friction: 0.8}) // ..................
// inside the log ..........................................................................
push(visuals, {x: 17, y: 48, w: 42, h: 13, type: "tree_interior", friction: 0.8}) // .......
// Base level of tree background ..........................................................
push(visuals, {x: 54, y: 61, w: 5, h: 1, type: "tree_interior"}) // .......................
push(visuals, {x: 56, y: 60, w: 4, h: 1, type: "tree_interior"}) // ......................
push(visuals, {x: 57, y: 59, w: 15, h: 1, type: "tree_interior"}) // ....................
push(visuals, {x: 58, y: 57, w: 2, h: 2, type: "tree_interior"}) // ....................
push(visuals, {x: 59, y: 0, w: 20, h: level.tile_height - 1, type: "tree_interior"}) //
// Then the tree platforms ............................................................
push(hitboxes, {x: 59, y: 42, w: 2, h: 8, type: "wood", friction: 0.8}) // ...........
push(hitboxes, {x: 59, y: 41, w: 2, h: 1, type: "moss", friction: 0.0}) // ............
push(hitboxes, {x: 59, y: 5, w: 2, h: 34, type: "wood", friction: 0.8}) // ...........
push(hitboxes, {x: 63, y: 46, w: 2, h: 8, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 65, y: 48, w: 1, h: 2, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 63, y: 45, w: 2, h: 1, type: "moss", friction: 0.1}) // ............
push(hitboxes, {x: 69, y: 44, w: 2, h: 9, type: "wood", friction: 0.8}) // ...........
push(hitboxes, {x: 69, y: 43, w: 2, h: 1, type: "moss", friction: 0.1}) // ............
push(hitboxes, {x: 65, y: 52, w: 2, h: 2, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 71, y: 52, w: 1, h: 1, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 71, y: 61, w: 11, h: 1, type: "wood", friction: 0.8}) // ...........
push(hitboxes, {x: 72, y: 60, w: 9, h: 1, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 74, y: 56, w: 5, h: 6, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 79, y: 59, w: 1, h: 1, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 75, y: 50, w: 4, h: 6, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 77, y: 49, w: 2, h: 2, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 77, y: 48, w: 2, h: 1, type: "moss", friction: 0.1}) // ............
push(hitboxes, {x: 76, y: 42, w: 3, h: 2, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 79, y: 53, w: 1, h: 2, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 79, y: 57, w: 1, h: 2, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 79, y: 61, w: 5, h: 1, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 81, y: 60, w: 1, h: 1, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 80, y: 59, w: 1, h: 1, type: "wood", friction: 0.8}) // ............
// Next stage of climibing ............................................................
push(hitboxes, {x: 63, y: 35, w: 2, h: 7, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 72, y: 30, w: 2, h: 11, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 77, y: 24, w: 2, h: 18, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 77, y: 5, w: 2, h: 16, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 77, y: 0, w: 2, h: 3, type: "wood", friction: 0.8}) // .............
push(hitboxes, {x: 59, y: 0, w: 24, h: 3, type: "wood", friction: 0.8}) // .............
push(hitboxes, {x: 81, y: 3, w: 2, h: 2, type: "wood", friction: 0.8}) // .............
push(hitboxes, {x: 79, y: 8, w: 1, h: 2, type: "wood", friction: 0.8}) // .............
// branches ...........................................................................
push(hitboxes, {x: 78, y: 24, w: 4, h: 1, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 82, y: 25, w: 3, h: 1, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 85, y: 24, w: 3, h: 1, type: "wood", friction: 0.8}) // ............
// Higher branch ......................................................................
push(hitboxes, {x: 78, y: 12, w: 7, h: 1, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 85, y: 11, w: 4, h: 1, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 89, y: 10, w: 4, h: 1, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 84, y: 13, w: 1, h: 1, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 85, y: 14, w: 1, h: 1, type: "wood", friction: 0.8}) // ............
push(hitboxes, {x: 86, y: 15, w: 6, h: 1, type: "wood", friction: 0.8}) // ............
// Moving platform ....................................................................
// Slats to stop flying to skip platform ..............................................
push(hitboxes, {x: 65, y: 3, w: 6, h: 4, type: "wood", friction: 0.8}) // .............
// Barrier to force player left if they fail the plaftorm .............................
push(hitboxes, {x: 65, y: 17, w: 12, h: 4, type: "wood", friction: 0.8}) // .............
// Branch to nest .....................................................................
push(hitboxes, {x: 35, y: 5, w: 24, h: 2, type: "wood", friction: 0.8}) // ............
nest = {x: 1, y: 32, w: 6, h: 4, type: "nest"} // .....................................
// Springy branches ...................................................................
springy_branches = [] // ..............................................................
push(springy_branches, {x: 88, y: 23, w: 3, h: 1, bounce: 1.4}) // ...................
// push(springy_branches, {x: 64, y: 0, w: 60, h: 20, bounce: 1.5}) // ...............
// push(springy_branches, {x: 64, y: 0, w: 60, h: 20, bounce: 1.5}) // ..............
// Wind sections (near canopy)......................................................
wind_zones = [] // ................................................................
// push(wind_zones, {x: 64, y: 0, w: 200, h: 100, strength: 2.5, direction: 1}) // 
// push(wind_zones, {x: 64, y: 0, w: 200, h: 100, strength: 3.125, direction: -1}) 
// push(wind_zones, {x: 64, y: 0, w: 200, h: 100, strength: 2.8125, direction: 1})
// Helper functin to get player height based on jump state.......................
fun player_height() { // .......................................................
 // ...........................................................................
  return match player.jump_state { // .........................................
   Gliding => player.glide_height, // .........................................
   _ => player.height // ......................................................
  } // ........................................................................
} // ..........................................................................
// Helper function to check collision..........................................
fun check_collision(px, py, pw, ph, bx, by, bw, bh) { // ......................
 // ...........................................................................
  return px < bx + bw && px + pw > bx && py < by + bh && py + ph > by // ......
} // ..........................................................................
// Helper to get platform at position (point check) ............................
fun get_platform_at(x, y) { // ................................................
 // ...........................................................................
  i = 0 // ....................................................................
  loop { // ...................................................................
   // .........................................................................
    if (i >= len(hitboxes)) { // .............................................
     // .......................................................................
      break // ................................................................
    } // ......................................................................
    p = hitboxes[i] // ........................................................
    if (check_collision(x, y, 1, 1, p.x, p.y, p.w, p.h)) { // .................
     // .......................................................................
      return p // .............................................................
    } // ......................................................................
    i = i + 1 // ..............................................................
  } // ........................................................................
  return null // ..............................................................
} // ..........................................................................
// Helper to get average friction under player (handles multiple platforms) ...
fun get_player_ground_friction() { // .........................................
 // Check left, center, and right of player's bottom ..........................
 foot_y = player.y + player_height() // .......................................
 left_x = player.x // .........................................................
 center_x = player.x + player.width / 2 // ....................................
 right_x = player.x + player.width - 0.1 // ...................................
 // Collect friction values from all contact points ...........................
 friction_sum = 0 // ..........................................................
 friction_count = 0 // ........................................................
 // Check left side ...........................................................
 left_platform = get_platform_at(left_x, foot_y) // ...........................
 if (left_platform != null) { // ..............................................
  friction_sum = friction_sum + left_platform.friction // ....................
  friction_count = friction_count + 1 // .....................................
 } // .........................................................................
 // Check center ..............................................................
 center_platform = get_platform_at(center_x, foot_y) // .......................
 if (center_platform != null) { // ............................................
  friction_sum = friction_sum + center_platform.friction // ..................
  friction_count = friction_count + 1 // .....................................
 } // .........................................................................
 // Check right side ..........................................................
 right_platform = get_platform_at(right_x, foot_y) // .........................
 if (right_platform != null) { // .............................................
  friction_sum = friction_sum + right_platform.friction // ...................
  friction_count = friction_count + 1 // .....................................
 } // .........................................................................
 // Return average friction, or default 0.8 if no platforms found .............
 if (friction_count > 0) { // .................................................
  return friction_sum / friction_count // ....................................
 } // .........................................................................
 return 0.8 // ................................................................
} // ...........................................................................
// Helper to get springy branch at position.......................................
fun get_springy_at(x, y) { // ...................................................
 // .............................................................................
  i = 0 // ......................................................................
  loop { // .....................................................................
   // ...........................................................................
    if (i >= len(springy_branches)) { // ........................................
     // .........................................................................
      break // ..................................................................
    } // ........................................................................
    b = springy_branches[i] // ....................................................
    if (check_collision(x, y, player.width, player_height(), b.x, b.y, b.w, b.h)) {
     // ...........................................................................
      return b // ................................................................
    } // ........................................................................
    i = i + 1 // ................................................................
  } // ..........................................................................
  return null // ................................................................
} // ............................................................................
// Helper to check if in wind zone...............................................
fun get_wind_at(x, y) { // ......................................................
 // .............................................................................
  i = 0 // ......................................................................
  loop { // .....................................................................
   // ...........................................................................
    if (i >= len(wind_zones)) { // ..............................................
     // .........................................................................
      break // ..................................................................
    } // ........................................................................
    w = wind_zones[i] // ........................................................
    if (x >= w.x && x < w.x + w.w && y >= w.y && y < w.y + w.h) { // ............
     // .........................................................................
      return w // ...............................................................
    } // ........................................................................
    i = i + 1 // ................................................................
  } // ..........................................................................
  return null // ................................................................
} // ............................................................................
// Update coyote time............................................................
fun update_coyote_time(dt) { // .................................................
 // .............................................................................
  if (player.jump_state == Grounded) { // .......................................
   // ...........................................................................
    player.coyote_time = player.coyote_time_max // ..............................
  } else { // ...................................................................
   // ...........................................................................
    player.coyote_time = player.coyote_time - dt // .............................
    if (player.coyote_time < 0) { // ............................................
     // .........................................................................
      player.coyote_time = 0 // .................................................
    } // ........................................................................
  } // ..........................................................................
} // ............................................................................
// Update jump buffer............................................................
fun update_jump_buffer(dt) { // .................................................
 // .............................................................................
  if (player.jump_state == Grounded && (pressed("jump") || key_pressed("Space"))) {
   player.jump_buffer = player.jump_buffer_max // ................................
  } else { // ...................................................................
   player.jump_buffer = player.jump_buffer - dt // .............................
   if (player.jump_buffer < 0) { // ............................................
    player.jump_buffer = 0 // .................................................
   } // ........................................................................
  } // ..........................................................................
} // ............................................................................
fun execute_jump() { // ........................................................
 // ...........................................................................
 // Calculate jump force with momentum boost ..................................
 momentum_boost = player.momentum * jump_force_momentum_mult // ...............
 jump_force = jump_force_base - momentum_boost // .............................
 player.vel_y = jump_force // .................................................
 player.coyote_time = 0 // ....................................................
 player.jump_buffer = 0 // ....................................................
 player.jump_state = Jumping // ...............................................
  } // ........................................................................
// Handle jump ................................................................
fun handle_jump() { // ........................................................
 match player.jump_state { // ................................................
  Jumping => { // ...........................................................
   // Gravity is much weaker while holding jump ............................
   if (released("jump")) { // ..................................................
    // Note that the player released jump while in the air, so now they can glide
     player.jump_state = PendingGlide // .......................................
   } // ........................................................................
   if (player.vel_y > 0) { // ..................................................
    player.jump_state = Falling // ............................................
   } // ........................................................................
   }, // .........................................................................
   Grounded => { // ..............................................................
    // ...........................................................................
     if ((pressed("jump") || player.jump_buffer > 0)) { // .......................
      execute_jump() // ..........................................................
     } else if (player.vel_y > 0) { // ...........................................
      player.jump_state = Falling // ............................................
     } // ........................................................................
   }, // .........................................................................
   Falling => { // ...............................................................
    if (pressed("jump")) { // ....................................................
     if (player.coyote_time > 0) { // ............................................
      execute_jump() // ..........................................................
     } else { // ..................................................................
      // ........................................................................... 
       player.jump_state = Gliding // .............................................
      } // ........................................................................
     } // .........................................................................
   }, // .........................................................................
   PendingGlide => { // ..........................................................
    // ...........................................................................
     if (held("jump")) { // ......................................................
      player.jump_state = Gliding // ............................................
     } // ........................................................................
    }, // ........................................................................
   Gliding => { // ...............................................................
    // ...........................................................................
     if (released("jump")) { // .................................................
      player.jump_state = Falling // ............................................
   } // ........................................................................
    }, // ........................................................................
    _ => {} // ..................................................................
 } // ............................................................................
} // ..............................................................................
// Handle horizontal movement with momentum........................................
fun handle_movement(dt) { // ......................................................
 // ...............................................................................
  left_input = held("left") || key_held("KeyA") // ................................
  right_input = held("right") || key_held("KeyD") // ..............................
   // .............................................................................
  // Determine input direction: -1=left, 0=none/both, 1=right .....................
  input_dir = 0 // ................................................................
  if (left_input && !right_input) { // ............................................
   input_dir = -1 // .............................................................
  } else if (right_input && !left_input) { // .....................................
   input_dir = 1 // ..............................................................
  } // ............................................................................
  // UPDATE MOMENTUM (works in air and on ground) ............................................
  moving_same_dir = (input_dir > 0 && player.vel_x > 0) || (input_dir < 0 && player.vel_x < 0)
  if (moving_same_dir && abs(player.vel_x) > ground_speed * 0.5) { // .......................
   // Gain momentum when moving in same direction with some speed ..........................
   if (player.jump_state == Grounded) { // ................................................
    player.momentum = player.momentum + player.momentum_gain * dt // .....................
    } else if (player.jump_state == Gliding) { // .......................................
     // Gain momentum in air at half the ground rate ...................................
     player.momentum = player.momentum + player.momentum_gain * 0.75 * dt // ..........
    } // .............................................................................
   if (player.momentum > player.momentum_max) { // ..................................
    player.momentum = player.momentum_max // .......................................
   } // ...........................................................................
  } else if (input_dir == 0 || !moving_same_dir) { // ............................
   // Lose momentum when not moving or changing direction .......................
   if (player.jump_state == Grounded) { // ......................................
    player.momentum = player.momentum - player.momentum_loss_ground * dt // .....
   } else { // ...................................................................
    player.momentum = player.momentum - player.momentum_loss_air * dt // ........
   } // ..........................................................................
   if (player.momentum < 0) { // .................................................
    player.momentum = 0 // ......................................................
   } // ..........................................................................
  } // ............................................................................
  if (player.jump_state == Grounded) { // .........................................
   // GROUND MOVEMENT .............................................................
    // Get average friction from platforms under player (handles straddling) ......
    friction = get_player_ground_friction() // ....................................
     // ...........................................................................
    // Acceleration/deceleration rates based on friction ..........................
    // Linear acceleration for smoother feel ......................................
    accel = 15.0 * friction // ....................................................
    decel = 20.0 * friction // ....................................................
    max_speed = ground_speed + player.momentum // .................................
     // ...........................................................................
    if (input_dir == 0) { // ......................................................
     // NO INPUT or BOTH INPUTS: decelerate to stop ...............................
      if (player.vel_x > 0) { // ..................................................
       // .........................................................................
        player.vel_x = player.vel_x - decel * dt // ...............................
        if (player.vel_x < 0) { // ................................................
         // .......................................................................
          player.vel_x = 0 // .....................................................
        } // ......................................................................
      } else if (player.vel_x < 0) { // ...........................................
       // .........................................................................
        player.vel_x = player.vel_x + decel * dt // ...............................
        if (player.vel_x > 0) { // ................................................
         // .......................................................................
          player.vel_x = 0 // .....................................................
        } // ......................................................................
      } // ........................................................................
    } else { // ...................................................................
     // INPUT PRESSED: accelerate or change direction .............................
      target_vel = input_dir * max_speed // .......................................
       // .........................................................................
      // Check if changing direction ................................................................
      changing_direction = (input_dir > 0 && player.vel_x < 0) || (input_dir < 0 && player.vel_x > 0)
       // ..........................................................................................
      if (changing_direction) { // ................................................................
       // CHANGING DIRECTION: decelerate first ...................................................
        if (player.vel_x > 0) { // ..............................................................
         // ....................................................................................
          player.vel_x = player.vel_x - decel * dt // .........................................
          if (player.vel_x < 0) { // .........................................................
           player.vel_x = 0 // ..............................................................
           } // ............................................................................
        } else { // .......................................................................
         player.vel_x = player.vel_x + decel * dt // .....................................
         if (player.vel_x > 0) { // ......................................................
          player.vel_x = 0 // ...........................................................
         } // ............................................................................
        } // ..............................................................................
      } else { // .........................................................................
       // ACCELERATING: add speed linearly ................................................
        player.vel_x = player.vel_x + input_dir * accel * dt // ...........................
         // ...............................................................................
        // Clamp to max speed .............................................................
        if (player.vel_x > max_speed) { // ................................................
         // ...............................................................................
          player.vel_x = max_speed // .....................................................
        } else if (player.vel_x < -max_speed) { // ........................................
         // ...............................................................................
          player.vel_x = -max_speed // ....................................................
        } // ..............................................................................
      } // ................................................................................
    } // ..................................................................................
  } else { // .............................................................................
   // AIR MOVEMENT: momentum with flat rate ...............................................
    air_accel = 18.0 // ...................................................................
     // ...................................................................................
    // Air max speed includes momentum bonus ..............................................
    // Gliding gets extra horizontal speed ................................................
    if (player.jump_state == Gliding) { // ................................................
     // ...................................................................................
      air_max = air_speed + player.momentum + 3.0 // ......................................
    } else { // ...........................................................................
     // ...................................................................................
      air_max = air_speed + player.momentum // ............................................
    } // ..................................................................................
     // ...................................................................................
    if (input_dir == 0) { // ..............................................................
     // NO INPUT or BOTH: coast with current velocity .....................................
    } else { // ...........................................................................
     // INPUT: accelerate toward target ...................................................
      target_vel = input_dir * air_max // .................................................
      diff = target_vel - player.vel_x // .................................................
       // .................................................................................
      // Only accelerate/decelerate if moving slower than target or changing direction ...
      // Preserve higher speeds when jumping to avoid immediate slowdown .................
      is_moving_faster_than_target = (input_dir > 0 && player.vel_x > air_max) || (input_dir < 0 && player.vel_x < -air_max)
      if (is_moving_faster_than_target) { // ..............................................................................
       // ................................................................................................................
        // Already moving faster than air_max in this direction - preserve speed ........................................
        // Only allow deceleration if changing direction ...............................................................
        changing_direction = (input_dir > 0 && player.vel_x < 0) || (input_dir < 0 && player.vel_x > 0) // ............
        if (changing_direction) { // .................................................................................
         // .........................................................................................................
          // Changing direction - decelerate toward zero first .....................................................
          if (player.vel_x > 0) { // ..............................................................................
           // ....................................................................................................
            player.vel_x = player.vel_x - air_accel * dt // .....................................................
            if (player.vel_x < 0) { // .........................................................................
             // ...............................................................................................
              player.vel_x = 0 // ............................................................................
            } // ............................................................................................
          } else { // ......................................................................................
           // .............................................................................................
            player.vel_x = player.vel_x + air_accel * dt // ..............................................
            if (player.vel_x > 0) { // ..................................................................
             // ........................................................................................
              player.vel_x = 0 // .....................................................................
            } // .....................................................................................
          } // ......................................................................................
        } // .......................................................................................
        // Otherwise, preserve current speed (coast) ..............................................
      } else { // ................................................................................
       // .......................................................................................
        // Moving slower than target - accelerate toward target ................................
        // Apply flat acceleration rate toward target .........................................
        if (abs(diff) < air_accel * dt) { // .................................................
         // .................................................................................
          player.vel_x = target_vel // ......................................................
        } else if (diff > 0) { // ...........................................................
         // .................................................................................
          player.vel_x = player.vel_x + air_accel * dt // ...................................
        } else { // .........................................................................
         // .................................................................................
          player.vel_x = player.vel_x - air_accel * dt // ...................................
        } // ................................................................................
      } // .................................................................................
    } // ..................................................................................
    // Coast with current velocity when no input ..........................................
  } // ....................................................................................
} // ......................................................................................
// Apply physics...........................................................................
fun apply_physics(dt) { // ................................................................
 // Gravity................................................................................
  match player.jump_state { // ............................................................
  // ......................................................................................
   Gliding => { // ........................................................................
    player.vel_y = min(player.vel_y + glide_gravity * dt, glide_velocity_min) // .........
    player.vel_y = max(player.vel_y + glide_gravity * dt, 0) // ...........................
   }, // ..................................................................................
   Jumping => { // ........................................................................
    // Still ascending and holding jump - weak gravity for higher jump ...................
     player.vel_y = player.vel_y + jump_held_gravity * dt // .............................
   }, // ..................................................................................
   _ => { // ..............................................................................
    player.vel_y = player.vel_y + gravity * dt // .........................................
   } // ...................................................................................
  } // ....................................................................................
  // Wind zones............................................................................
  wind = get_wind_at(player.x + player.width / 2, player.y + player_height() / 2) // .....
  if (wind != null) { // ..................................................................
   // .....................................................................................
    player.vel_x = player.vel_x + wind.strength * wind.direction * dt // ..................
  } // ....................................................................................
  // Update position.......................................................................
  player.x = player.x + player.vel_x * dt // ..............................................
  player.y = player.y + player.vel_y * dt // ..............................................
} // ......................................................................................
// Handle collisions.......................................................................
// Corner correction threshold - how far past edge before nudging (0.5 = halfway) ........
corner_correction_threshold = 0.75 // .....................................................
falling_corner_correction_threshold = 0.10 // .............................................
corner_correction_strength = 0.1 // ......................................................
fun handle_collisions() { // ..............................................................
 // .......................................................................................
  // .....................................................................................
  // Check platform collisions.............................................................
  i = 0 // ................................................................................
  loop { // ...............................................................................
   // .....................................................................................
    if (i >= len(hitboxes)) { // .........................................................
     // ...................................................................................
      break // ............................................................................
    } // ..................................................................................
    p = hitboxes[i] // ...................................................................
    if (check_collision(player.x, player.y, player.width, player_height(), p.x, p.y, p.w, p.h)) {
     // ........................................................................................
      // Calculate overlap amounts to determine which collision to resolve ....................
      overlap_top = (player.y + player_height()) - p.y // .....................................
      overlap_bottom = (p.y + p.h) - player.y // .............................................
      overlap_left = (player.x + player.width) - p.x // ......................................
      overlap_right = (p.x + p.w) - player.x // .............................................
       // .....................................................................................
      // Determine which axis has the smallest overlap (most likely collision direction) ......
      min_overlap = min(min(overlap_top, overlap_bottom), min(overlap_left, overlap_right)) // 
       // .....................................................................................
      // CORNER CORRECTION for ceiling collisions ............................................
      // If hitting ceiling and more than halfway past edge, nudge player out ................
      corner_corrected = false // ...........................................................
      if (player.vel_y < 0 && overlap_bottom < player_height() * 2) { // ....................
       // Check if player is near left edge of platform .....................................
        player_center = player.x + player.width / 2 // ......................................
        past_left = p.x - player_center // ..................................................
        past_right = player_center - (p.x + p.w) // .........................................
         // .................................................................................
        // Near left edge - nudge left ......................................................
        if (past_left > 0 && past_left < player.width * corner_correction_threshold) { // ...
         // .................................................................................
          player.x = p.x - player.width - corner_correction_strength// ......................
          corner_corrected = true // ........................................................
        } // ................................................................................
        // Near right edge - nudge right ....................................................
        else if (past_right > 0 && past_right < player.width * corner_correction_threshold) {
         // .................................................................................
          player.x = p.x + p.w + corner_correction_strength // ..............................
          corner_corrected = true // ........................................................
        } // ................................................................................
      } // ..................................................................................
       // ...................................................................................
      // CORNER CORRECTION for falling into gaps ............................................
      // Only apply when hitting SIDE (not landing on top) while falling ...................
      is_side_collision = (min_overlap == overlap_left || min_overlap == overlap_right) // .
      if (player.vel_y > 0 && is_side_collision && overlap_top < player_height()) {  //.....
       // Check horizontal overlap to determine if player should land or fall through gap ...
        // Use the overlap corresponding to the side collision (min_overlap is the side overlap)
        horizontal_overlap = min_overlap // .......................................................
         // ........................................................................................
        // If horizontal overlap is small (player mostly past platform), nudge to fall through gap .............
        if (horizontal_overlap > 0 && horizontal_overlap < player.width * falling_corner_correction_threshold) {
         // ....................................................................................................
          // Check which side we're on and nudge away from platform ...........................................
          if (player.x + player.width / 2 < p.x + p.w / 2) { // ..............................................
           // ...............................................................................................
            player.x = player.x - corner_correction_strength // ............................................
          } else { // .....................................................................................
           // ............................................................................................
            player.x = player.x + corner_correction_strength // .........................................
          } // .........................................................................................
        } // ..........................................................................................
      } // ...........................................................................................
       // ...........................................................................................
      // Top collision (landing) - player moving down and landing on top of platform ...............
      if (min_overlap == overlap_top && player.vel_y > 0 && player.y < p.y) { // ..................
       // ........................................................................................
        // If gliding, we need to account for height change when landing ........................
        was_gliding = player.jump_state == Gliding // ...........................................
        player.jump_state = Grounded // .........................................................
        // Position player on top of platform using full height .................................
        player.y = p.y - player.height // .......................................................
        player.vel_y = 0 // ....................................................................
        player.coyote_time = player.coyote_time_max // ........................................
      } // .....................................................................................
      // Bottom collision (ceiling) - player moving up and hitting bottom of platform above ...
      // Skip if corner correction was applied - maintain upward velocity .......................
      else if (min_overlap == overlap_bottom && player.vel_y < 0 && !corner_corrected && player.y + player_height() > p.y + p.h && player.y < p.y + p.h) {
       // ...............................................................................................................................................
        player.y = p.y + p.h // ........................................................................................................................
        player.vel_y = 0 // ...........................................................................................................................
      } // ...........................................................................................................................................
      // Right collision - player moving right and hitting left side of platform ....................................................................
      else if (min_overlap == overlap_left && player.vel_x > 0 && player.x + player.width > p.x && player.x < p.x) { // ............................
       // .........................................................................................................................................
        player.x = p.x - player.width // .........................................................................................................
        player.vel_x = 0 // .....................................................................................................................
      }  // ....................................................................................................................................
      // Left collision - player moving left and hitting right side of platform ...............................................................
      else if (min_overlap == overlap_right && player.vel_x < 0 && player.x < p.x + p.w && player.x + player.width > p.x + p.w) { // .........
       // ...................................................................................................................................
        player.x = p.x + p.w // ............................................................................................................
        player.vel_x = 0 // ...............................................................................................................
      }  // ..............................................................................................................................
      // Fallback: if no velocity-based collision matches, resolve by smallest overlap ..................................................
      // Only resolve vertical collisions if player is actually moving in that direction ...............................................
      else if (!corner_corrected && min_overlap == overlap_top && player.y < p.y && player.vel_y > 0) { // ............................
       // ............................................................................................................................
        player.jump_state = Grounded // .............................................................................................
        player.y = p.y - player.height // ..........................................................................................
        player.vel_y = 0 // ........................................................................................................
        player.coyote_time = player.coyote_time_max // .............................................................................
      } else if (!corner_corrected && min_overlap == overlap_bottom && player.y + player_height() > p.y + p.h && player.vel_y < 0) { 
       // .........................................................................................................................
        player.y = p.y + p.h // ..................................................................................................
        player.vel_y = 0 // .....................................................................................................
      } else if (min_overlap == overlap_left && player.x < p.x) { // ...........................................................
       // .....................................................................................................................
        player.x = p.x - player.width // .....................................................................................
        player.vel_x = 0 // .................................................................................................
      } else if (min_overlap == overlap_right && player.x + player.width > p.x + p.w) { // .................................
       // .................................................................................................................
        player.x = p.x + p.w // ..........................................................................................
        player.vel_x = 0 // .............................................................................................
      } // .............................................................................................................
    } // ..............................................................................................................
    i = i + 1 // .....................................................................................................
  } // ..............................................................................................................
  // Check springy branch collisions................................................................................
  springy = get_springy_at(player.x, player.y) // .................................................................
  if (springy != null && player.vel_y > 0 && player.y < springy.y) { // ..........................................
   // ...........................................................................................................
    player.y = springy.y - player_height() // ..................................................................
    // Calculate jump force with momentum boost for springy branch ............................................
    momentum_boost = player.momentum * jump_force_momentum_mult // ...........................................
    min_jump_force = (jump_force_base + momentum_boost) * springy.bounce // .................................
    player.vel_y = min_jump_force // .......................................................................
    player.jump_state = Jumping // ........................................................................
  } // ...................................................................................................
  // Check nest collision (win condition).......................................................................
  if (check_collision(player.x, player.y, player.width, player_height(), nest.x, nest.y, nest.w, nest.height)) {
   // .........................................................................................................
    game_state = Won // ......................................................................................
  } // ......................................................................................................
} // .......................................................................................................
// Update camera...........................................................................................
fun update_camera(dt) { // ...............................................................................
 // Calculate camera viewport size in world coordinates (tiles) .........................................
  // Use camera dimensions directly (already in tiles) .................................................
  camera_view_width_tiles = camera.width // ...........................................................
  camera_view_height_tiles = camera.height // ........................................................
   // ...............................................................................................
  // Calculate half viewport dimensions for centering ..............................................
  half_view_width = camera_view_width_tiles / 2 // ................................................
  half_view_height = camera_view_height_tiles / 2 // .............................................
   // ...........................................................................................
  // Camera max speed in tiles per second (constant speed, not proportional to distance) .......
  camera_max_speed = 15.0 // ..................................................................
   // ........................................................................................
  // Set camera bounds ......................................................................
  min_camera_x = half_view_width // ........................................................
  max_camera_x = level.tile_width - half_view_width // ...................................................
  min_camera_y = half_view_height // .....................................................................
  max_camera_y = level.tile_height - half_view_height // .................................................
   // ....................................................................................................
  // Horizontal camera following .........................................................................
  // Center camera on player horizontally ................................................................
  desired_camera_x = player.x + player.width / 2 // ......................................................
   // ....................................................................................................
  // Clamp desired position to bounds ....................................................................
  if (max_camera_x < min_camera_x) { // ..................................................................
   // ....................................................................................................
    // Viewport is larger than level, center camera in level .............................................
    target_camera_x = level.tile_width / 2 // ............................................................
  } else { // ............................................................................................
   // ....................................................................................................
    target_camera_x = clamp(desired_camera_x, min_camera_x, max_camera_x) // .............................
  } // ...................................................................................................
   // ....................................................................................................
  // Smoothly move camera X toward target with constant max speed ........................................
  diff_x = target_camera_x - camera.x // .................................................................
  max_move_x = camera_max_speed * dt // ..................................................................
  if (abs(diff_x) <= max_move_x) { // ....................................................................
   // ....................................................................................................
    camera.x = target_camera_x // ........................................................................
  } else if (diff_x > 0) { // ............................................................................
   // ....................................................................................................
    camera.x = camera.x + max_move_x // ..................................................................
  } else { // ............................................................................................
   // ....................................................................................................
    camera.x = camera.x - max_move_x // ..................................................................
  } // ...................................................................................................
   // ....................................................................................................
  // Vertical camera following ...........................................................................
  // Center camera on player vertically ..................................................................
  desired_camera_y = player.y + player_height() / 2 // ...................................................
   // ....................................................................................................
  // Clamp desired position to bounds ....................................................................
  if (max_camera_y < min_camera_y) { // ..................................................................
   // ....................................................................................................
    // Viewport is larger than level, center camera in level .............................................
    target_camera_y = level.tile_height / 2 // ...........................................................
  } else { // ............................................................................................
   // ....................................................................................................
    target_camera_y = clamp(desired_camera_y, min_camera_y, max_camera_y) // .............................
  } // ...................................................................................................
   // ....................................................................................................
  // Smoothly move camera Y toward target with constant max speed ........................................
  diff_y = target_camera_y - camera.y // .................................................................
  max_move_y = camera_max_speed * dt // ..................................................................
  if (abs(diff_y) <= max_move_y) { // ....................................................................
   // ....................................................................................................
    camera.y = target_camera_y // ........................................................................
  } else if (diff_y > 0) { // ............................................................................
   // ....................................................................................................
    camera.y = camera.y + max_move_y // ..................................................................
  } else { // ............................................................................................
   // ....................................................................................................
    camera.y = camera.y - max_move_y // ..................................................................
  } // ...................................................................................................
} // .....................................................................................................
// Get platform color.....................................................................................
fun get_platform_color(platform) { // ....................................................................
 // ......................................................................................................
  return match platform.type { // ........................................................................
   // ....................................................................................................
    "ground" => "#8B4513", // ............................................................................
    "apple" => "#ff0000", // .............................................................................
    "stem" => "#00ff00", // ..............................................................................
    "tree_interior" => "#45283C", // ....................................................................
    "wood" => "#422823", // ............................................................................
    "rock" => "#555555", // ..............................................................................
    "growth" => "#8B4513", // ............................................................................
    "moss" => "#2F4F2F", // ..............................................................................
    _ => "#808080" // ....................................................................................
  } // ...................................................................................................
} // .....................................................................................................
// Convert tile coordinate to screen coordinates .........................................................
fun tile_to_screen(x, y) { // ............................................................................
 // Convert tile coordinates to screen coordinates, centering camera .....................................
  // Camera is centered on screen, so offset by half screen size .........................................
  // Convert tiles to pixels: (world_x - camera.x) * camera.scale, then center on screen .................
  screen_x = (x - camera.x) * camera.scale + width() / 2 // ..............................................
  screen_y = (y - camera.y) * camera.scale + height() / 2 // .............................................
  return {x: screen_x, y: screen_y} // ...................................................................
} // .....................................................................................................
// Draw function..........................................................................................
draw { // ................................................................................................
 // ......................................................................................................
  clear("#87CEEB") // ....................................................................................
   // ....................................................................................................
  // Draw background gradient (sky to ground).............................................................
  i = 0 // ...............................................................................................
  loop { // ..............................................................................................
   // ....................................................................................................
    if (i >= height()) { // ..............................................................................
     // ..................................................................................................
      break // ...........................................................................................
    } // .................................................................................................
    t = i / height() // ..................................................................................
    r = lerp(135, 139, t) // .............................................................................
    g = lerp(206, 69, t) // ..............................................................................
    b = lerp(250, 19, t) // ..............................................................................
    color = rgb(r, g, b) // ..............................................................................
    rect(0, i, width(), 1, color) // .....................................................................
    i = i + 1 // .........................................................................................
  } // ...................................................................................................
  // Draw visuals (non-collision background elements).....................................................
  i = 0 // ...............................................................................................
  loop { // ..............................................................................................
   // ....................................................................................................
    if (i >= len(visuals)) { // ..........................................................................
     // ..................................................................................................
      break // ...........................................................................................
    } // .................................................................................................
    v = visuals[i] // ...................................................................................
    cooridnates = tile_to_screen(v.x, v.y) // ............................................................
    if (cooridnates != null) { // ........................................................................
     // ..................................................................................................
      color = get_platform_color(v) // ...................................................................
      rect(cooridnates.x, cooridnates.y, v.w * camera.scale, v.h * camera.scale, color) // ...............
    } // .................................................................................................
    i = i + 1 // .........................................................................................
  } // ...................................................................................................
   // Draw hitboxes.......................................................................................
  i = 0 // ...............................................................................................
  loop { // ..............................................................................................
   // ....................................................................................................
    if (i >= len(hitboxes)) { // ........................................................................
     // ..................................................................................................
      break // ...........................................................................................
    } // .................................................................................................
    p = hitboxes[i] // ..................................................................................
    cooridnates = tile_to_screen(p.x, p.y) // ............................................................
    if (cooridnates != null) { // ........................................................................
     // ..................................................................................................
      color = get_platform_color(p) // ...................................................................
      rect(cooridnates.x, cooridnates.y, p.w * camera.scale, p.h * camera.scale, color) // ...............
    } // .................................................................................................
    i = i + 1 // .........................................................................................
  } // ...................................................................................................
  // Draw springy branches (green)........................................................................
  i = 0 // ...............................................................................................
  loop { // ..............................................................................................
   // ....................................................................................................
    if (i >= len(springy_branches)) { // .................................................................
     // ..................................................................................................
      break // ...........................................................................................
    } // .................................................................................................
    b = springy_branches[i] // ...........................................................................
    cooridnates = tile_to_screen(b.x, b.y) // ............................................................
    if (cooridnates != null) { // ........................................................................
     // ..................................................................................................
      rect(cooridnates.x, cooridnates.y, b.w * camera.scale, b.h * camera.scale, "#00FF00") // ...........
    } // .................................................................................................
    i = i + 1 // .........................................................................................
  } // ...................................................................................................
   // ....................................................................................................
  // Draw wind zones (visual indicator)...................................................................
  i = 0 // ...............................................................................................
  loop { // ..............................................................................................
   // ....................................................................................................
    if (i >= len(wind_zones)) { // .......................................................................
     // ..................................................................................................
      break // ...........................................................................................
    } // .................................................................................................
    w = wind_zones[i] // .................................................................................
    alpha = 0.3 // .......................................................................................
    if (w.direction > 0) { // ............................................................................
     // ..................................................................................................
      color = rgba(200, 200, 255, alpha) // ..............................................................
    } else { // ..........................................................................................
     // ..................................................................................................
      color = rgba(255, 200, 200, alpha) // ..............................................................
    } // .................................................................................................
    cooridnates = tile_to_screen(w.x, w.y) // ............................................................
    if (cooridnates != null) { // ........................................................................
     // ..................................................................................................
      rect(cooridnates.x, cooridnates.y, w.w * camera.scale, w.h * camera.scale, color) // ...............
     } // ................................................................................................
    i = i + 1 // .........................................................................................
  } // ...................................................................................................
  // Draw nest............................................................................................
  nest_cooridnates = tile_to_screen(nest.x, nest.y) // ...................................................
  if (nest_cooridnates != null) { // ....................................................................
   // ..................................................................................................
    circle(nest_cooridnates.x, nest_cooridnates.y, 25, "#FFD700") // ..................................
    rect(nest_cooridnates.x - 15, nest_cooridnates.y + 10, 30, 10, "#8B4513") // .....................
  } // ..............................................................................................
   // ..............................................................................................
  // Draw player...................................................................................
  player_cooridnates = tile_to_screen(player.x, player.y) // .....................................
  player_width_px = player.width * camera.scale // ..............................................
  player_height_px = player_height() * camera.scale // .........................................
  rect(player_cooridnates.x, player_cooridnates.y, player_width_px, player_height_px, "#FFA500") 
   // ..........................................................................................
  // Draw height display........................................................................
  height_cm = 31 * camera.scale - (player.y + player_height()) * camera.scale // ...............
  max_height_message = "Max Height: " + round(max_height / 2) + " mm" // .......................
  message = "Height: " + round(height_cm / 2) + " mm" // .......................................
  match menu_state { // ........................................................................
   None => { // ................................................................................
    text(max_height_message, 20, 60, 24, "#FFFFFF") // .........................................
    text(message, 20, 90, 24, "#FFFFFF") // ....................................................
   }, // .......................................................................................
   _ => {} // ..................................................................................
  } // .........................................................................................
  // Draw menus.................................................................................
  match menu_state { // ........................................................................
   // ..........................................................................................
    Pause => draw_pause_menu(), // .............................................................
    _ => {} // .................................................................................
  } // .........................................................................................
} // ...........................................................................................
// Draw pause menu..............................................................................
fun draw_pause_menu() { // .....................................................................
 // Dark overlay................................................................................
  rect(0, 0, width(), height(), rgba(0, 0, 0, 0.85)) // .......................................
  // Menu panel.................................................................................
  panel_x = screen.width / 2 - 200 // ..........................................................
  panel_y = screen.height / 2 - 150 // .........................................................
  panel_w = 400 // .............................................................................
  panel_h = 300 // .............................................................................
  rect(panel_x, panel_y, panel_w, panel_h, "#1a1a2e") // .......................................
  rect(panel_x, panel_y, panel_w, panel_h, "#16213e", 0.5) // ..................................
   // ..........................................................................................
  // Title......................................................................................
  text("Paused", panel_x + panel_w / 2 - 60, panel_y + 40, 32, "#ffffff") // ...................
   // ..........................................................................................
} // ...........................................................................................
// Handle menu input............................................................................
fun handle_menu_input() { // ...................................................................
 // ............................................................................................
  // Open/close pause menu......................................................................
  if (pressed("start") || key_pressed("Escape")) { // ..........................................
   // ..........................................................................................
    match menu_state { // ......................................................................
     // ........................................................................................
      None => { // .............................................................................
      // .......................................................................................
       menu_state = Pause // ...................................................................
      }, // ....................................................................................
      Pause => { // ............................................................................
       // ......................................................................................
        menu_state = None // ...................................................................
      }, // ....................................................................................
      _ => {} // ...............................................................................
      } // .....................................................................................
  } // .........................................................................................
} // ...........................................................................................
// Update function..............................................................................
update(dt) { // ................................................................................
 // ............................................................................................
  // Handle menu input..........................................................................
  handle_menu_input() // .......................................................................
   // ..........................................................................................
  // Only update game if playing and not in menu................................................
  should_update = match menu_state { // ........................................................
   // ..........................................................................................
    None => true, // ...........................................................................
    _ => false // ..............................................................................
  } // .........................................................................................
  is_playing = match game_state { // ...........................................................
   // ..........................................................................................
    Won => load_scene("assets/rage/victory.rage"), // ..........................................
    Playing => true, // ........................................................................
    _ => false // ..............................................................................
  } // .........................................................................................
  if (!should_update  ||  !is_playing) { // ....................................................
   // ..........................................................................................
    return // ..................................................................................
  } // .........................................................................................
   // ..........................................................................................
  // Update input buffers.......................................................................
  update_coyote_time(dt) // ....................................................................
  update_jump_buffer(dt) // ....................................................................
   // ..........................................................................................
  // Handle input...............................................................................
  handle_jump() // .............................................................................
  handle_movement(dt) // .......................................................................
   // ..........................................................................................
  // Apply physics..............................................................................
  apply_physics(dt) // .........................................................................
   // ..........................................................................................
  // Handle collisions..........................................................................
  handle_collisions() // .......................................................................
   // ..........................................................................................
  // Update max height..........................................................................
  current_height = 31 * camera.scale - (player.y + player_height()) * camera.scale // ..........
  if (current_height > max_height) { // ........................................................
   max_height = current_height // ..............................................................
  } // .........................................................................................
   // ..........................................................................................
  // Update camera..............................................................................
  update_camera(dt) // .........................................................................
} // ...........................................................................................
################################################################################################