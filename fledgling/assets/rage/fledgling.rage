// Fledgling - A Ragelang Game 
// A fledgling bird must return to its nest at the top of a tree
// State enums..................................................
enum GameState { // ............................................
 // ............................................................
  Playing, // ..................................................
  Won, // ......................................................
  Paused // ....................................................
} // ...........................................................
enum MenuState { // ............................................
 // ............................................................
  None, // .....................................................
  Pause // ....................................................
} // ...........................................................
enum JumpState { // ............................................
 // ............................................................
  Grounded, // .................................................
  Jumping, // ..................................................
  Gliding, // ..................................................
  PendingGlide, // .............................................
  Falling // ..................................................
} // ...........................................................
// Game state...................................................
game_state = Playing // ........................................
menu_state = None // ..........................................
nest_y = 50 // ...............................................
nest_x = 4450 // ............................................
max_height = 0 // ............................................
// Audio settings (0-10 scale, passed to music() and sound())
// Use like: music("assets/sounds/music.mp3", music_volume)..
// Use like: sound("assets/sounds/jump.wav", sfx_volume).....
sfx_volume = 5 // ...........................................
music_volume = 5 // .........................................
// Level....................................................
level = { // ................................................
 // .........................................................
  tile_size: 32, // .........................................
  tile_width: 64, // ........................................
  tile_height: 32, // ........................................
  width: 64 * 64, // .........................................
  height: 32 * 64 // .........................................
} // ........................................................
screen = { // ...............................................
 // .........................................................
  width: width(), // ........................................
  height: height() // ......................................
} // ........................................................
// TODO Camera should take screen size into account ........
camera = { // ................................................
 // ..........................................................
  width: 15, // .............................................
  height: 9 // .............................................
} // .........................................................
// Calculate camera scale based on screen size ..............
camera.scale = min(floor(screen.width / camera.width), floor(screen.height / camera.height))
// Player...................................................................................
player = prototype() // ...................................................................
player.x = 2.0 // ........................................................................
player.y = 30.0 // ......................................................................
// Initialize camera position to center on player .........................................
camera.x = player.x + 0.5 // ...............................................................
camera.y = player.y + 0.5 // ...............................................................
player.vel_x = 0 // ....................................................................
player.vel_y = 0 // ...................................................................
player.width = 1 // ..................................................................
player.height = 1 // ................................................................
player.jump_state = Grounded // ....................................................
player.coyote_time = 0 // .........................................................
player.coyote_time_max = 0.15 // .................................................
player.jump_buffer = 0 // .......................................................
player.jump_buffer_max = 0.15 // ...............................................
player.jump_held = false // ....................................................
player.momentum = 0 // ........................................................
player.momentum_max = 4.0 // .................................................
player.momentum_gain = 5.0 // ...............................................
player.momentum_loss_air = 4.7 // ..........................................
player.momentum_loss_ground = 6.25 // .....................................
// Physics constants (values in tiles per second) ........................
gravity = 37.5 // .......................................................
jump_force_base = -9 // ................................................
jump_force_momentum_mult = 0.3 // .....................................
jump_held_gravity = 18.0 // ..........................................
glide_force = -6.25 // ..............................................
glide_gravity = 9.0 // .............................................
glide_velocity_min = 6.25 // .......................................
air_control = 1.0 // ..............................................
ground_control = 1.0 // ..........................................
ground_speed = 3.0 // ...........................................
air_speed = 2.5 // .............................................
// Level geometry...............................................
platforms = [] // ..............................................
// Ground section platforms....................................
// Coordinates are in tiles, not pixels .......................
// Ground covers the whole bottom of the level ...............
push(platforms, {x: 0, y: 31, w: level.tile_width, h: 1, type: "ground", friction: 1.0})
// Trunk is the left hand side of the level, all the way up ............................
push(platforms, {x: 0, y: 0, w: 2, h: level.tile_height, type: "trunk", friction: 1.0})
// Sideways apple is on screenc // ....................................................
push(platforms, {x: 10, y: 28, w: 2, h: 3, type: "apple", friction: 0.5}) // ..........
push(platforms, {x: 12, y: 30, w: 1, h: 1, type: "apple", friction: 0.5}) // ..........
push(platforms, {x: 12, y: 28, w: 1, h: 1, type: "apple", friction: 0.5}) // .........
push(platforms, {x: 9, y: 29, w: 1, h: 1, type: "stem", friction: 0.8}) // ..........
// vertical apple as well, simpler because bottom stem is at the bottom of the level
push(platforms, {x: 17, y: 28, w: 3, h: 3, type: "apple", friction: 0.5}) // ......
push(platforms, {x: 18, y: 27, w: 1, h: 1, type: "stem", friction: 0.8}) // ......
// Springy branches .............................................................
springy_branches = [] // .......................................................
push(springy_branches, {x: 64, y: 0, w: 60, h: 20, bounce: 1.5}) // ............
push(springy_branches, {x: 64, y: 0, w: 60, h: 20, bounce: 1.5}) // ............
push(springy_branches, {x: 64, y: 0, w: 60, h: 20, bounce: 1.5}) // ............
// Wind sections (near canopy).................................................
wind_zones = [] // ............................................................
push(wind_zones, {x: 64, y: 0, w: 200, h: 100, strength: 2.5, direction: 1}) //
push(wind_zones, {x: 64, y: 0, w: 200, h: 100, strength: 3.125, direction: -1})
push(wind_zones, {x: 64, y: 0, w: 200, h: 100, strength: 2.8125, direction: 1})
// Swells for gaining altitude................................................
swells = [] // ...............................................................
push(swells, {x: 64, y: 0, w: 150, h: 80, strength: 3.75}) // .................
push(swells, {x: 64, y: 0, w: 150, h: 80, strength: 4.6875}) // ...............
push(swells, {x: 64, y: 0, w: 150, h: 80, strength: 5.625}) // ................
// Camera......................................................................
// Helper function to check collision..........................................
fun check_collision(px, py, pw, ph, bx, by, bw, bh) { // ......................
 // ...........................................................................
  return px < bx + bw && px + pw > bx && py < by + bh && py + ph > by // ......
} // ..........................................................................
// Helper to get platform at position..........................................
fun get_platform_at(x, y) { // ................................................
 // ...........................................................................
  i = 0 // ....................................................................
  loop { // ...................................................................
   // .........................................................................
    if (i >= len(platforms)) { // .............................................
     // .......................................................................
      break // ................................................................
    } // ......................................................................
    p = platforms[i] // .......................................................
    if (check_collision(x, y, player.width, player.height, p.x, p.y, p.w, p.h)) { 
     // .........................................................................
      return p // ...............................................................
    } // ........................................................................
    i = i + 1 // ................................................................
  } // ..........................................................................
  return null // ................................................................
} // ............................................................................
// Helper to get springy branch at position......................................
fun get_springy_at(x, y) { // ...................................................
 // .............................................................................
  i = 0 // ......................................................................
  loop { // .....................................................................
   // ...........................................................................
    if (i >= len(springy_branches)) { // ........................................
     // .........................................................................
      break // ..................................................................
    } // ........................................................................
    b = springy_branches[i] // ..................................................
    if (check_collision(x, y, player.width, player.height, b.x, b.y, b.w, b.h)) {
     // .........................................................................
      return b // ...............................................................
    } // ........................................................................
    i = i + 1 // ................................................................
  } // ..........................................................................
  return null // ................................................................
} // ............................................................................
// Helper to check if in wind zone...............................................
fun get_wind_at(x, y) { // ......................................................
 // .............................................................................
  i = 0 // ......................................................................
  loop { // .....................................................................
   // ...........................................................................
    if (i >= len(wind_zones)) { // ..............................................
     // .........................................................................
      break // ..................................................................
    } // ........................................................................
    w = wind_zones[i] // ........................................................
    if (x >= w.x && x < w.x + w.w && y >= w.y && y < w.y + w.h) { // ............
     // .........................................................................
      return w // ...............................................................
    } // ........................................................................
    i = i + 1 // ................................................................
  } // ..........................................................................
  return null // ................................................................
} // ............................................................................
// Helper to check if in swell...................................................
fun get_swell_at(x, y) { // .....................................................
 // .............................................................................
  i = 0 // ......................................................................
  loop { // .....................................................................
   // ...........................................................................
    if (i >= len(swells)) { // ..................................................
     // .........................................................................
      break // ..................................................................
    } // ........................................................................
    s = swells[i] // ............................................................
    if (x >= s.x && x < s.x + s.w && y >= s.y && y < s.y + s.h) { // ............
     // .........................................................................
      return s // ...............................................................
    } // ........................................................................
    i = i + 1 // ................................................................
  } // ..........................................................................
  return null // ................................................................
} // ............................................................................
// Update coyote time............................................................
fun update_coyote_time(dt) { // .................................................
 // .............................................................................
  if (player.jump_state == Grounded) { // .......................................
   // ...........................................................................
    player.coyote_time = player.coyote_time_max // ..............................
  } else { // ...................................................................
   // ...........................................................................
    player.coyote_time = player.coyote_time - dt // .............................
    if (player.coyote_time < 0) { // ............................................
     // .........................................................................
      player.coyote_time = 0 // .................................................
    } // ........................................................................
  } // ..........................................................................
} // ............................................................................
// Update jump buffer............................................................
fun update_jump_buffer(dt) { // .................................................
 // .............................................................................
  if (player.jump_state == Grounded && (pressed("jump") || key_pressed("Space"))) {
   player.jump_buffer = player.jump_buffer_max // ................................
  } else { // ...................................................................
   player.jump_buffer = player.jump_buffer - dt // .............................
   if (player.jump_buffer < 0) { // ............................................
    player.jump_buffer = 0 // .................................................
   } // ........................................................................
  } // ..........................................................................
} // ............................................................................
fun execute_jump() { // ........................................................
 // ...........................................................................
 // Calculate jump force with momentum boost ..................................
 momentum_boost = player.momentum * jump_force_momentum_mult // ...............
 jump_force = jump_force_base + momentum_boost // .............................
 player.vel_y = jump_force // .................................................
 player.coyote_time = 0 // ....................................................
 player.jump_buffer = 0 // ....................................................
 player.jump_state = Jumping // ...............................................
  } // ........................................................................
// Handle jump ................................................................
fun handle_jump() { // ........................................................
 match player.jump_state { // ................................................
  Jumping => { // ...........................................................
   // Gravity is much weaker while holding jump ............................
   if (released("jump")) { // ..................................................
    // Note that the player released jump while in the air, so now they can glide
     player.jump_state = PendingGlide // .......................................
   } // ........................................................................
   if (player.vel_y > 0) { // ..................................................
    player.jump_state = Falling // ............................................
   } // ........................................................................
   }, // .........................................................................
   Grounded => { // ..............................................................
    // ...........................................................................
     if ((pressed("jump") || player.jump_buffer > 0)) { // .......................
      execute_jump() // ..........................................................
     } else if (player.vel_y > 0) { // ...........................................
      player.jump_state = Falling // ............................................
     } // ........................................................................
   }, // .........................................................................
   Falling => { // ...............................................................
    if (pressed("jump")) { // ....................................................
     if (player.coyote_time > 0) { // ............................................
      execute_jump() // ..........................................................
     } else { // ..................................................................
      // ........................................................................... 
       player.jump_state = Gliding // .............................................
      } // ........................................................................
     } // .........................................................................
   }, // .........................................................................
   PendingGlide => { // ..........................................................
    // ...........................................................................
     if (held("jump")) { // ......................................................
      player.jump_state = Gliding // ............................................
     } // ........................................................................
    }, // ........................................................................
   Gliding => { // ...............................................................
    // ...........................................................................
     if (released("jump")) { // .................................................
      player.jump_state = Falling // ............................................
   } // ........................................................................
    }, // ........................................................................
    _ => {} // ..................................................................
 } // ............................................................................
} // ..............................................................................
// Handle horizontal movement with momentum........................................
fun handle_movement(dt) { // ......................................................
 // ...............................................................................
  left_input = held("left") || key_held("KeyA") // ................................
  right_input = held("right") || key_held("KeyD") // ..............................
   // .............................................................................
  // Determine input direction: -1=left, 0=none/both, 1=right .....................
  input_dir = 0 // ................................................................
  if (left_input && !right_input) { // ............................................
   input_dir = -1 // .............................................................
  } else if (right_input && !left_input) { // .....................................
   input_dir = 1 // ..............................................................
  } // ............................................................................
  if (player.jump_state == Grounded) { // .........................................
   // GROUND MOVEMENT .............................................................
    // Get friction from platform (default 0.8) ...................................
    platform = get_platform_at(player.x, player.y + player.height + 1) // .........
    friction = 0.8 // .............................................................
    if (platform != null) { // ....................................................
     // ...........................................................................
      friction = platform.friction // .............................................
    } // ..........................................................................
     // ...........................................................................
    // Acceleration/deceleration rates based on friction ..........................
    // Linear acceleration for smoother feel ......................................
    accel = 15.0 * friction // ....................................................
    decel = 20.0 * friction // ....................................................
    max_speed = ground_speed + player.momentum_max // .............................
     // ...........................................................................
    if (input_dir == 0) { // ......................................................
     // NO INPUT or BOTH INPUTS: decelerate to stop ...............................
      if (player.vel_x > 0) { // ..................................................
       // .........................................................................
        player.vel_x = player.vel_x - decel * dt // ...............................
        if (player.vel_x < 0) { // ................................................
         // .......................................................................
          player.vel_x = 0 // .....................................................
        } // ......................................................................
      } else if (player.vel_x < 0) { // ...........................................
       // .........................................................................
        player.vel_x = player.vel_x + decel * dt // ...............................
        if (player.vel_x > 0) { // ................................................
         // .......................................................................
          player.vel_x = 0 // .....................................................
        } // ......................................................................
      } // ........................................................................
    } else { // ...................................................................
     // INPUT PRESSED: accelerate or change direction .............................
      target_vel = input_dir * max_speed // .......................................
       // .........................................................................
      // Check if changing direction ................................................................
      changing_direction = (input_dir > 0 && player.vel_x < 0) || (input_dir < 0 && player.vel_x > 0)
       // ..........................................................................................
      if (changing_direction) { // ................................................................
       // CHANGING DIRECTION: decelerate first ...................................................
        if (player.vel_x > 0) { // ..............................................................
         // ....................................................................................
          player.vel_x = player.vel_x - decel * dt // .........................................
          if (player.vel_x < 0) { // .........................................................
           player.vel_x = 0 // ..............................................................
           } // ............................................................................
        } else { // .......................................................................
         player.vel_x = player.vel_x + decel * dt // .....................................
         if (player.vel_x > 0) { // ......................................................
          player.vel_x = 0 // ...........................................................
         } // ............................................................................
        } // ..............................................................................
      } else { // .........................................................................
       // ACCELERATING: add speed linearly ................................................
        player.vel_x = player.vel_x + input_dir * accel * dt // ...........................
         // ...............................................................................
        // Clamp to max speed .............................................................
        if (player.vel_x > max_speed) { // ................................................
         // ...............................................................................
          player.vel_x = max_speed // .....................................................
        } else if (player.vel_x < -max_speed) { // ........................................
         // ...............................................................................
          player.vel_x = -max_speed // ....................................................
        } // ..............................................................................
      } // ................................................................................
    } // ..................................................................................
  } else { // .............................................................................
   // AIR MOVEMENT: momentum with flat rate ...............................................
    air_accel = 18.0 // ...................................................................
     // ...................................................................................
    // Gliding gets faster horizontal speed ...............................................
    if (player.jump_state == Gliding) { // ................................................
     // ...................................................................................
      air_max = air_speed + 3.0 // ........................................................
    } else { // ...........................................................................
     // ...................................................................................
      air_max = air_speed // ..............................................................
    } // ..................................................................................
     // ...................................................................................
    if (input_dir == 0) { // ..............................................................
     // NO INPUT or BOTH: coast with current velocity .....................................
    } else { // ...........................................................................
     // INPUT: accelerate toward target ...................................................
      target_vel = input_dir * air_max // .................................................
      diff = target_vel - player.vel_x // .................................................
       // .................................................................................
      // Only accelerate/decelerate if moving slower than target or changing direction ...
      // Preserve higher speeds when jumping to avoid immediate slowdown .................
      is_moving_faster_than_target = (input_dir > 0 && player.vel_x > air_max) || (input_dir < 0 && player.vel_x < -air_max)
      if (is_moving_faster_than_target) { // ..............................................................................
       // ................................................................................................................
        // Already moving faster than air_max in this direction - preserve speed ........................................
        // Only allow deceleration if changing direction ...............................................................
        changing_direction = (input_dir > 0 && player.vel_x < 0) || (input_dir < 0 && player.vel_x > 0) // ............
        if (changing_direction) { // .................................................................................
         // .........................................................................................................
          // Changing direction - decelerate toward zero first .....................................................
          if (player.vel_x > 0) { // ..............................................................................
           // ....................................................................................................
            player.vel_x = player.vel_x - air_accel * dt // .....................................................
            if (player.vel_x < 0) { // .........................................................................
             // ...............................................................................................
              player.vel_x = 0 // ............................................................................
            } // ............................................................................................
          } else { // ......................................................................................
           // .............................................................................................
            player.vel_x = player.vel_x + air_accel * dt // ..............................................
            if (player.vel_x > 0) { // ..................................................................
             // ........................................................................................
              player.vel_x = 0 // .....................................................................
            } // .....................................................................................
          } // ......................................................................................
        } // .......................................................................................
        // Otherwise, preserve current speed (coast) ..............................................
      } else { // ................................................................................
       // .......................................................................................
        // Moving slower than target - accelerate toward target ................................
        // Apply flat acceleration rate toward target .........................................
        if (abs(diff) < air_accel * dt) { // .................................................
         // .................................................................................
          player.vel_x = target_vel // ......................................................
        } else if (diff > 0) { // ...........................................................
         // .................................................................................
          player.vel_x = player.vel_x + air_accel * dt // ...................................
        } else { // .........................................................................
         // .................................................................................
          player.vel_x = player.vel_x - air_accel * dt // ...................................
        } // ................................................................................
      } // .................................................................................
    } // ..................................................................................
    // Coast with current velocity when no input ..........................................
  } // ....................................................................................
} // ......................................................................................
// Apply physics...........................................................................
fun apply_physics(dt) { // ................................................................
 // Gravity................................................................................
  match player.jump_state { // ............................................................
  // ......................................................................................
   Gliding => { // ........................................................................
    player.vel_y = min(player.vel_y + glide_gravity * dt, glide_velocity_min) // .........
    player.vel_y = max(player.vel_y + glide_gravity * dt, 0) // ...........................
   }, // ..................................................................................
   Jumping => { // ........................................................................
    // Still ascending and holding jump - weak gravity for higher jump ...................
     player.vel_y = player.vel_y + jump_held_gravity * dt // .............................
   }, // ..................................................................................
   _ => { // ..............................................................................
    player.vel_y = player.vel_y + gravity * dt // .........................................
   } // ...................................................................................
  } // ....................................................................................
  // Wind zones............................................................................
  wind = get_wind_at(player.x + player.width / 2, player.y + player.height / 2) // ........
  if (wind != null) { // ..................................................................
   // .....................................................................................
    player.vel_x = player.vel_x + wind.strength * wind.direction * dt // ..................
  } // ....................................................................................
   // .....................................................................................
  // Swells................................................................................
  swell = get_swell_at(player.x + player.width / 2, player.y + player.height / 2) // ......
  if (swell != null && player.jump_state == Gliding) { // .................................
   // .....................................................................................
    player.vel_y = player.vel_y - swell.strength * dt // ..................................
  } // ....................................................................................
   // .....................................................................................
  // Update position.......................................................................
  player.x = player.x + player.vel_x * dt // ..............................................
  player.y = player.y + player.vel_y * dt // ..............................................
} // ......................................................................................
// Handle collisions.......................................................................
// Corner correction threshold - how far past edge before nudging (0.5 = halfway) ........
corner_correction_threshold = 0.5 // ......................................................
corner_correction_strength = 0.3 // ......................................................
fun handle_collisions() { // ..............................................................
 // .......................................................................................
  // .....................................................................................
  // Check platform collisions.............................................................
  i = 0 // ................................................................................
  loop { // ...............................................................................
   // .....................................................................................
    if (i >= len(platforms)) { // .........................................................
     // ...................................................................................
      break // ............................................................................
    } // ..................................................................................
    p = platforms[i] // ...................................................................
    if (check_collision(player.x, player.y, player.width, player.height, p.x, p.y, p.w, p.h)) {
     // ......................................................................................
      // Calculate overlap amounts to determine which collision to resolve ..................
      overlap_top = (player.y + player.height) - p.y // ......................................
      overlap_bottom = (p.y + p.h) - player.y // .............................................
      overlap_left = (player.x + player.width) - p.x // ......................................
      overlap_right = (p.x + p.w) - player.x // .............................................
       // .....................................................................................
      // Determine which axis has the smallest overlap (most likely collision direction) ......
      min_overlap = min(min(overlap_top, overlap_bottom), min(overlap_left, overlap_right)) // 
       // .....................................................................................
      // CORNER CORRECTION for ceiling collisions ............................................
      // If hitting ceiling and more than halfway past edge, nudge player out ................
      corner_corrected = false // ...........................................................
      if (player.vel_y < 0 && overlap_bottom < player.height * 2) { // .......................
       // Check if player is near left edge of platform .....................................
        player_center = player.x + player.width / 2 // ......................................
        past_left = p.x - player_center // ..................................................
        past_right = player_center - (p.x + p.w) // .........................................
         // .................................................................................
        // Near left edge - nudge left ......................................................
        if (past_left > 0 && past_left < player.width * corner_correction_threshold) { // ...
         // .................................................................................
          player.x = player.x - corner_correction_strength // ...............................
          corner_corrected = true // ........................................................
        } // ................................................................................
        // Near right edge - nudge right ....................................................
        else if (past_right > 0 && past_right < player.width * corner_correction_threshold) {
         // .................................................................................
          player.x = player.x + corner_correction_strength // ...............................
          corner_corrected = true // ........................................................
        } // ................................................................................
      } // ..................................................................................
       // ...................................................................................
      // CORNER CORRECTION for falling into gaps ............................................
      // Only apply when hitting SIDE (not landing on top) while falling ...................
      is_side_collision = (min_overlap == overlap_left || min_overlap == overlap_right) // .
      if (player.vel_y > 0 && is_side_collision && overlap_top < player.height) { // .......
       // Check if player is near top of platform ...........................................
        player_bottom = player.y + player.height // .........................................
        past_top = player_bottom - p.y // ...................................................
         // .................................................................................
        // Mostly past top edge - nudge horizontally into gap ...............................
        if (past_top > 0 && past_top < player.height * corner_correction_threshold) { // ....
         // .................................................................................
          // Check which side we're on and nudge away from platform .........................
          if (player.x + player.width / 2 < p.x + p.w / 2) { // .............................
           // ...............................................................................
            player.x = player.x - corner_correction_strength // .............................
          } else { // .......................................................................
           // ...............................................................................
            player.x = player.x + corner_correction_strength // .............................
          } // ..............................................................................
        } // ................................................................................
      } // ..................................................................................
       // .....................................................................................
      // Top collision (landing) - player moving down and landing on top of platform .........
      if (min_overlap == overlap_top && player.vel_y > 0 && player.y < p.y) { // ............
       // .....................................................................................
        player.y = p.y - player.height // .....................................................
        player.vel_y = 0 // ...................................................................
        player.jump_state = Grounded // ........................................................
        player.coyote_time = player.coyote_time_max // ........................................
      } // .....................................................................................
      // Bottom collision (ceiling) - player moving up and hitting bottom of platform above ...
      // Skip if corner correction was applied - maintain upward velocity .......................
      else if (min_overlap == overlap_bottom && player.vel_y < 0 && !corner_corrected && player.y + player.height > p.y + p.h && player.y < p.y + p.h) {
       // .............................................................................................................................................
        player.y = p.y + p.h // ......................................................................................................................
        player.vel_y = 0 // .........................................................................................................................
      } // .........................................................................................................................................
      // Right collision - player moving right and hitting left side of platform ..................................................................
      else if (min_overlap == overlap_left && player.vel_x > 0 && player.x + player.width > p.x && player.x < p.x) { // ..........................
       // .......................................................................................................................................
        player.x = p.x - player.width // .......................................................................................................
        player.vel_x = 0 // ...................................................................................................................
      }  // ..................................................................................................................................
      // Left collision - player moving left and hitting right side of platform .............................................................
      else if (min_overlap == overlap_right && player.vel_x < 0 && player.x < p.x + p.w && player.x + player.width > p.x + p.w) { // .......
       // .................................................................................................................................
        player.x = p.x + p.w // ..........................................................................................................
        player.vel_x = 0 // .............................................................................................................
      }  // ............................................................................................................................
      // Fallback: if no velocity-based collision matches, resolve by smallest overlap ................................................
      // Only resolve vertical collisions if player is actually moving in that direction .............................................
      else if (min_overlap == overlap_top && player.y < p.y && player.vel_y > 0) { // ...............................................
       // ..........................................................................................................................
        player.y = p.y - player.height // .........................................................................................
        player.vel_y = 0 // ......................................................................................................
        player.jump_state = Grounded // .........................................................................................
        player.coyote_time = player.coyote_time_max // .........................................................................
      } else if (min_overlap == overlap_bottom && player.y + player.height > p.y + p.h && player.vel_y < 0) { // ..............
       // ....................................................................................................................
        player.y = p.y + p.h // .............................................................................................
        player.vel_y = 0 // ................................................................................................
      } else if (min_overlap == overlap_left && player.x < p.x) { // ......................................................
       // ................................................................................................................
        player.x = p.x - player.width // ................................................................................
        player.vel_x = 0 // ............................................................................................
      } else if (min_overlap == overlap_right && player.x + player.width > p.x + p.w) { // ............................
       // ............................................................................................................
        player.x = p.x + p.w // .....................................................................................
        player.vel_x = 0 // ........................................................................................
      } // ........................................................................................................
    } // .........................................................................................................
    i = i + 1 // ................................................................................................
  } // .........................................................................................................
   // .........................................................................................................
  // Check springy branch collisions..........................................................................
  springy = get_springy_at(player.x, player.y) // ...........................................................
  if (springy != null && player.vel_y > 0 && player.y < springy.y) { // ....................................
   // .....................................................................................................
    player.y = springy.y - player.height // ..............................................................
    player.vel_y = player.vel_y * -springy.bounce // ....................................................
    // Calculate jump force with momentum boost for springy branch .....................................
    momentum_boost = player.momentum * jump_force_momentum_mult // ....................................
    min_jump_force = jump_force_base + momentum_boost // .............................................
    if (player.vel_y < min_jump_force) { // .........................................................
     // ............................................................................................
      player.vel_y = min_jump_force // ............................................................
    } // .........................................................................................
    player.jump_state = Jumping // ..............................................................
    player.jump_held = held("jump") || key_held("Space") // ....................................
  } // ........................................................................................
   // .........................................................................................
  // Check nest collision (win condition)..................................................................
  if (check_collision(player.x, player.y, player.width, player.height, nest_x - 20, nest_y - 20, 40, 40)) {
   // .....................................................................................................
    game_state = Won // ...................................................................................
  } // ....................................................................................................
} // ......................................................................................................
// Update camera...........................................................................................
fun update_camera(dt) { // ................................................................................
 // Calculate camera viewport size in world coordinates (tiles) ...........................................
  // Viewport size in pixels divided by tile size gives viewport in tiles ................................
  camera_view_width_tiles = screen.width / level.tile_size // .............................................
  camera_view_height_tiles = screen.height / level.tile_size // ...........................................
   // .......................................................................................................
  // Calculate half viewport dimensions for centering ......................................................
  half_view_width = camera_view_width_tiles / 2 // .........................................................
  half_view_height = camera_view_height_tiles / 2 // ........................................................
   // .......................................................................................................
  // Camera max speed in tiles per second (constant speed, not proportional to distance) ..................
  camera_max_speed = 12.0 // ...............................................................................
   // .......................................................................................................
  // Camera lock threshold in tiles ........................................................................
  camera_lock_threshold_x = camera.width / 2 // .............................................................
  camera_lock_threshold_y = camera.height / 2 // ............................................................
   // .......................................................................................................
  // Horizontal camera following with edge constraints ......................................................
  // Center camera on player horizontally ...................................................................
  desired_camera_x = player.x + player.width / 2 // ........................................................
   // .......................................................................................................
  // Clamp camera to level boundaries horizontally (use tile_width, not width in pixels) ..................
  min_camera_x = half_view_width // ........................................................................
  max_camera_x = level.tile_width - half_view_width // .....................................................
   // .......................................................................................................
  // Calculate viewport edges for horizontal locking .......................................................
  viewport_left = desired_camera_x - half_view_width // .....................................................
  viewport_right = desired_camera_x + half_view_width // ....................................................
   // .......................................................................................................
  // Calculate target X position based on locking/following ................................................
  target_camera_x = desired_camera_x // .....................................................................
  if (viewport_left <= camera_lock_threshold_x) { // ........................................................
   // .......................................................................................................
    // Lock camera at left .................................................................................
    target_camera_x = min_camera_x // ......................................................................
  } else if (viewport_right >= level.tile_width - camera_lock_threshold_x) { // ............................
   // .......................................................................................................
    // Lock camera at right ................................................................................
    target_camera_x = max_camera_x // ......................................................................
  } else { // ..............................................................................................
   // ......................................................................................................
    // Normal camera following .............................................................................
    // Ensure bounds are valid (viewport might be larger than level) .......................................
    if (max_camera_x < min_camera_x) { // ..................................................................
     // ...................................................................................................
      // Viewport is larger than level, center camera in level ............................................
      target_camera_x = level.tile_width / 2 // ............................................................
    } else if (desired_camera_x < min_camera_x) { // ........................................................
     // ...................................................................................................
      target_camera_x = min_camera_x // ....................................................................
    } else if (desired_camera_x > max_camera_x) { // .........................................................
     // ...................................................................................................
      target_camera_x = max_camera_x // ....................................................................
    } // .................................................................................................
  } // ....................................................................................................
   // .......................................................................................................
  // Smoothly move camera X toward target with constant max speed ..........................................
  diff_x = target_camera_x - camera.x // ....................................................................
  max_move_x = camera_max_speed * dt // .....................................................................
  if (abs(diff_x) <= max_move_x) { // .......................................................................
   // ......................................................................................................
    camera.x = target_camera_x // ..........................................................................
  } else if (diff_x > 0) { // ..............................................................................
   // ......................................................................................................
    camera.x = camera.x + max_move_x // ....................................................................
  } else { // ..............................................................................................
   // ......................................................................................................
    camera.x = camera.x - max_move_x // ....................................................................
  } // .....................................................................................................
   // .......................................................................................................
  // Vertical camera following with edge constraints .......................................................
  // Center camera on player vertically ...................................................................
  desired_camera_y = player.y + player.height / 2 // .......................................................
   // ......................................................................................................
  // Clamp camera to level boundaries vertically (use tile_height, not height in pixels) .................
  min_camera_y = half_view_height // .......................................................................
  max_camera_y = level.tile_height - half_view_height // ...................................................
   // ......................................................................................................
  // Top of viewport would be at: desired_camera_y - half_view_height ....................................
  // Bottom of viewport would be at: desired_camera_y + half_view_height .................................
  viewport_top = desired_camera_y - half_view_height // .....................................................
  viewport_bottom = desired_camera_y + half_view_height // ..................................................
   // ......................................................................................................
  // Calculate target Y position based on locking/following ................................................
  target_camera_y = desired_camera_y // .....................................................................
  if (viewport_top <= camera_lock_threshold_y) { // .........................................................
   // ......................................................................................................
    // Lock camera at top .................................................................................
    target_camera_y = min_camera_y // ......................................................................
  } else if (viewport_bottom >= level.tile_height - camera_lock_threshold_y) { // ..........................
   // ......................................................................................................
    // Lock camera at bottom ...............................................................................
    target_camera_y = max_camera_y // ......................................................................
  } else { // ..............................................................................................
   // ......................................................................................................
    // Normal camera following .............................................................................
    // Ensure bounds are valid (viewport might be larger than level) .......................................
    if (max_camera_y < min_camera_y) { // .................................................................
     // ...................................................................................................
      // Viewport is larger than level, center camera in level ............................................
      target_camera_y = level.tile_height / 2 // ...........................................................
    } else if (desired_camera_y < min_camera_y) { // ........................................................
     // ...................................................................................................
      target_camera_y = min_camera_y // ....................................................................
    } else if (desired_camera_y > max_camera_y) { // .........................................................
     // ...................................................................................................
      target_camera_y = max_camera_y // ....................................................................
    } // .................................................................................................
  } // ....................................................................................................
   // .......................................................................................................
  // Smoothly move camera Y toward target with constant max speed ..........................................
  diff_y = target_camera_y - camera.y // ....................................................................
  max_move_y = camera_max_speed * dt // .....................................................................
  if (abs(diff_y) <= max_move_y) { // .......................................................................
   // ......................................................................................................
    camera.y = target_camera_y // ..........................................................................
  } else if (diff_y > 0) { // ..............................................................................
   // ......................................................................................................
    camera.y = camera.y + max_move_y // ....................................................................
  } else { // ..............................................................................................
   // ......................................................................................................
    camera.y = camera.y - max_move_y // ....................................................................
  } // .....................................................................................................
} // ......................................................................................................
// Get platform color......................................................................................
fun get_platform_color(platform) { // .....................................................................
 // .......................................................................................................
  return match platform.type { // .........................................................................
   // .....................................................................................................
    "ground" => "#8B4513", // .............................................................................
    "apple" => "#ff0000", // ..............................................................................
    "stem" => "#00ff00", // ...............................................................................
    "trunk" => "#8B4513", // ..............................................................................
    "dung" => "#8B4513", // ...............................................................................
    "branch" => "#8B4513", // .............................................................................
    "moss" => "#2F4F2F", // ...............................................................................
    _ => "#808080" // .....................................................................................
  } // ....................................................................................................
} // ......................................................................................................
// Convert tile coordinate to screen coordinates ..........................................................
fun tile_to_screen(x, y) { // .............................................................................
 // Convert tile coordinates to screen coordinates, centering camera ......................................
  // Camera is centered on screen, so offset by half screen size .........................................
  // Convert tiles to pixels: (world_x - camera.x) * tile_size, then center on screen ...................
  screen_x = (x - camera.x) * level.tile_size + screen.width / 2 // .......................................
  screen_y = (y - camera.y) * level.tile_size + screen.height / 2 // ......................................
  return {x: screen_x, y: screen_y} // ...................................................................
} // ......................................................................................................
// Draw function...........................................................................................
draw { // .................................................................................................
 // .......................................................................................................
  clear("#87CEEB") // .....................................................................................
   // .....................................................................................................
  // Draw background gradient (sky to ground)..............................................................
  i = 0 // ................................................................................................
  loop { // ...............................................................................................
   // .....................................................................................................
    if (i >= screen.height) { // ..........................................................................
     // ...................................................................................................
      break // ............................................................................................
    } // ..................................................................................................
    t = i / screen.height // ..............................................................................
    r = lerp(135, 139, t) // ..............................................................................
    g = lerp(206, 69, t) // ...............................................................................
    b = lerp(250, 19, t) // ...............................................................................
    color = rgb(r, g, b) // ...............................................................................
    rect(0, i, screen.width, 1, color) // .................................................................
    i = i + 1 // ..........................................................................................
  } // ....................................................................................................
   // .....................................................................................................
  // Draw platforms........................................................................................
  i = 0 // ................................................................................................
  loop { // ...............................................................................................
   // .....................................................................................................
    if (i >= len(platforms)) { // .........................................................................
     // ...................................................................................................
      break // ............................................................................................
    } // ..................................................................................................
    p = platforms[i] // ...................................................................................
    cooridnates = tile_to_screen(p.x, p.y) // .............................................................
    if (cooridnates != null) { // .........................................................................
     // ...................................................................................................
      color = get_platform_color(p) // ....................................................................
      rect(cooridnates.x, cooridnates.y, p.w * level.tile_size, p.h * level.tile_size, color) // ..........
    } // ..................................................................................................
    i = i + 1 // ..........................................................................................
  } // ....................................................................................................
   // .....................................................................................................
  // Draw springy branches (green).........................................................................
  i = 0 // ................................................................................................
  loop { // ...............................................................................................
   // .....................................................................................................
    if (i >= len(springy_branches)) { // ..................................................................
     // ...................................................................................................
      break // ............................................................................................
    } // ..................................................................................................
    b = springy_branches[i] // ............................................................................
    cooridnates = tile_to_screen(b.x, b.y) // .............................................................
    if (cooridnates != null) { // .........................................................................
     // ...................................................................................................
      rect(cooridnates.x, cooridnates.y, p.w * level.tile_size, p.h * level.tile_size, "#00FF00") // ......
    } // ..................................................................................................
    i = i + 1 // .........................................................................................
  } // ...................................................................................................
   // ....................................................................................................
  // Draw wind zones (visual indicator)...................................................................
  i = 0 // ...............................................................................................
  loop { // ..............................................................................................
   // ....................................................................................................
    if (i >= len(wind_zones)) { // .......................................................................
     // ..................................................................................................
      break // ...........................................................................................
    } // .................................................................................................
    w = wind_zones[i] // .................................................................................
    alpha = 0.3 // .......................................................................................
    if (w.direction > 0) { // ............................................................................
     // ..................................................................................................
      color = rgba(200, 200, 255, alpha) // ..............................................................
    } else { // ..........................................................................................
     // ..................................................................................................
      color = rgba(255, 200, 200, alpha) // ..............................................................
    } // .................................................................................................
    cooridnates = tile_to_screen(w.x, w.y) // ............................................................
    if (cooridnates != null) { // ........................................................................
     // ..................................................................................................
      rect(cooridnates.x, cooridnates.y, w.w * level.tile_size, w.h * level.tile_size, color) // .........
     } // ................................................................................................
    i = i + 1 // .........................................................................................
  } // ...................................................................................................
   // ....................................................................................................
  // Draw swells (visual indicator).......................................................................
  i = 0 // ...............................................................................................
  loop { // ..............................................................................................
   // ....................................................................................................
    if (i >= len(swells)) { // ...........................................................................
     // ..................................................................................................
      break // ...........................................................................................
    } // .................................................................................................
    s = swells[i] // ....................................................................................
    color = rgba(100, 200, 255, 0.4) // ................................................................
    cooridnates = tile_to_screen(s.x, s.y) // ............................................................
    if (cooridnates != null) { // ........................................................................
     // ..................................................................................................
      rect(cooridnates.x, cooridnates.y, s.w * level.tile_size, s.h * level.tile_size, color) // .........
     } // ................................................................................................
    i = i + 1 // .........................................................................................
  } // ...................................................................................................
   // ....................................................................................................
  // Draw nest............................................................................................
  nest_cooridnates = tile_to_screen(nest_x, nest_y) // ....................................................
  if (nest_cooridnates != null) { // ......................................................................
   // .....................................................................................................
    circle(nest_cooridnates.x, nest_cooridnates.y, 25, "#FFD700") // ......................................
    rect(nest_cooridnates.x - 15, nest_cooridnates.y + 10, 30, 10, "#8B4513") // ..........................
  } // ....................................................................................................
   // .....................................................................................................
  // Draw player...........................................................................................
  player_cooridnates = tile_to_screen(player.x, player.y) // ...............................................
  player_width_px = player.width * level.tile_size // ......................................................
  player_height_px = player.height * level.tile_size // ....................................................
  if (player.jump_state == Gliding) { // ..................................................................
   // Draw gliding bird (wings spread).....................................................................
    rect(player_cooridnates.x + player_width_px / 2 - 5, player_cooridnates.y - player_height_px / 2, 10, player_height_px, "#FFA500")
  } // ...............................................................................................................................
  circle(player_cooridnates.x + player_width_px / 2, player_cooridnates.y + player_height_px / 2, player_width_px / 2, "#FFA500") // .
   // ................................................................................................................................
  // Draw height display..............................................................................................................
  height_cm = 31 * level.tile_size - (player.y + player.height) * level.tile_size // .................................................
  max_height_message = "Max Height: " + round(max_height) + " cm" // .................................................................
  message = "Height: " + round(height_cm) + " cm" // .................................................................................
  match menu_state { // .............................................................................................................
   None => { // .....................................................................................................................
    text(max_height_message, 20, 30, 24, "#FFFFFF") // ........................................................................................................................................................................
    text(message, 20, 60, 24, "#FFFFFF") // ........................................................................................................................................................................
   }, // ..............................................................................................................................................................................................................
   _ => {} // ..............................................................................................................................................................................................................
  } // ......................................................................................................................................................................................................................
  // Draw menus..............................................................................................................................................................................................................
  match menu_state { // .....................................................................................................................................................................................................
   // .......................................................................................................................................................................................................................
    Pause => draw_pause_menu(), // ..........................................................................................................................................................................................
    _ => {} // ..............................................................................................................................................................................................................
  } // ......................................................................................................................................................................................................................
} // ........................................................................................................................................................................................................................
// Draw pause menu...........................................................................................................................................................................................................
fun draw_pause_menu() { // ..................................................................................................................................................................................................
 // Dark overlay.............................................................................................................................................................................................................
  rect(0, 0, screen.width, screen.height, rgba(0, 0, 0, 0.85)) // ..........................................................................................................................................................
   // .......................................................................................................................................................................................................................
  // Menu panel..............................................................................................................................................................................................................
  panel_x = screen.width / 2 - 200 // .......................................................................................................................................................................................
  panel_y = screen.height / 2 - 150 // ......................................................................................................................................................................................
  panel_w = 400 // ..........................................................................................................................................................................................................
  panel_h = 300 // ..........................................................................................................................................................................................................
  rect(panel_x, panel_y, panel_w, panel_h, "#1a1a2e") // ....................................................................................................................................................................
  rect(panel_x, panel_y, panel_w, panel_h, "#16213e", 0.5) // ...............................................................................................................................................................
   // .......................................................................................................................................................................................................................
  // Title...................................................................................................................................................................................................................
  text("Paused", panel_x + panel_w / 2 - 60, panel_y + 40, 32, "#ffffff") // ................................................................................................................................................
   // .......................................................................................................................................................................................................................
} // ........................................................................................................................................................................................................................
// Handle menu input.........................................................................................................................................................................................................
fun handle_menu_input() { // ................................................................................................................................................................................................
 // .........................................................................................................................................................................................................................
  // Open/close pause menu...................................................................................................................................................................................................
  if (pressed("start") || key_pressed("Escape")) { // .......................................................................................................................................................................
   // .......................................................................................................................................................................................................................
    match menu_state { // ...................................................................................................................................................................................................
     // ....................................................................................................................................................................................................................
      None => { // .........................................................................................................................................................................................................
      // ...................................................................................................................................................................................................................
       menu_state = Pause // ...............................................................................................................................................................................................
       menu_selection = Resume // ..........................................................................................................................................................................................
      }, // ................................................................................................................................................................................................................
      Pause => { // ........................................................................................................................................................................................................
       // ..................................................................................................................................................................................................................
        menu_state = None // ...............................................................................................................................................................................................
      }, // ................................................................................................................................................................................................................
      _ => {} // ...........................................................................................................................................................................................................
      } // .................................................................................................................................................................................................................
  } // .....................................................................................................................................................................................................................
} // .......................................................................................................................................................................................................................
// Update function...........................................................................................................................................................................................................
update(dt) { // .............................................................................................................................................................................................................
 // .........................................................................................................................................................................................................................
  // Handle menu input.......................................................................................................................................................................................................
  handle_menu_input() // ....................................................................................................................................................................................................
   // .......................................................................................................................................................................................................................
  // Only update game if playing and not in menu.............................................................................................................................................................................
  should_update = match menu_state { // .....................................................................................................................................................................................
   // .......................................................................................................................................................................................................................
    None => true, // ........................................................................................................................................................................................................
    _ => false // ...........................................................................................................................................................................................................
  } // ......................................................................................................................................................................................................................
  is_playing = match game_state { // ........................................................................................................................................................................................
   // .......................................................................................................................................................................................................................
    Won => load_scene("assets/rage/victory.rage"), // .......................................................................................................................................................................
    Playing => true, // .....................................................................................................................................................................................................
    _ => false // ...........................................................................................................................................................................................................
  } // ......................................................................................................................................................................................................................
  if (!should_update  ||  !is_playing) { // .................................................................................................................................................................................
   // .......................................................................................................................................................................................................................
    return // ...............................................................................................................................................................................................................
  } // ......................................................................................................................................................................................................................
   // .......................................................................................................................................................................................................................
  // Update input buffers....................................................................................................................................................................................................
  update_coyote_time(dt) // .................................................................................................................................................................................................
  update_jump_buffer(dt) // .................................................................................................................................................................................................
   // .......................................................................................................................................................................................................................
  // Handle input............................................................................................................................................................................................................
  handle_jump() // ..........................................................................................................................................................................................................
  handle_movement(dt) // ....................................................................................................................................................................................................
   // .......................................................................................................................................................................................................................
  // Apply physics...........................................................................................................................................................................................................
  apply_physics(dt) // ......................................................................................................................................................................................................
   // .......................................................................................................................................................................................................................
  // Handle collisions.......................................................................................................................................................................................................
  handle_collisions() // ....................................................................................................................................................................................................
   // .......................................................................................................................................................................................................................
  // Update max height.......................................................................................................................................................................................................
  current_height = 31 * level.tile_size - (player.y + player.height) * level.tile_size // ...................................................................................................................................
  if (current_height > max_height) { // .....................................................................................................................................................................................
   // .......................................................................................................................................................................................................................
    max_height = current_height // .........................................................................................................................................................................................
  } // ......................................................................................................................................................................................................................
   // .......................................................................................................................................................................................................................
  // Update camera...........................................................................................................................................................................................................
  update_camera(dt) // ........................................................................................................................................................................................................
} // ........................................................................................................................................................................................................................
#############################################################################################################################################################################################################################